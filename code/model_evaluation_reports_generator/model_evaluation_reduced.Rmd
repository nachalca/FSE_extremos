---
title: "`r paste0('Model evaluation for ', params$variable)`"
header-includes:
   - \usepackage{bbm}
params:
  variable: "tas" #Use pr as default
output: html_document
---

```{css}
/* Define a margin before h2 element */
h2 {
  margin-top: 3em;
}
```

```{r imports, include=FALSE}
library(here)
library(tidyverse)
library(knitr)
library(gridExtra)
library(yaml)
library("extremogram")
source('code/metrics.R')
source('code/utils.R')
```

```{r load_data}
params <- vector(mode = 'list')
params$variable <- 'tas' 

res <- paste0('data/model_evaluation_data/', params$variable, ".csv") |> read.csv()  
#Load configuration
conf <- yaml.load_file("code/conf.yml")
```




The observations for the validation were taken from `r min(res$time)` to `r max(res$time)`.

Remember that we have on a daily scale the variables `sfcWind`, `tas`, `pr`, `tasmax`, `tasmin` and `psl` and in a monthly scale `clt`, `rsdt`,`rsds` as a predictors. We also have the month `r  if (conf[["VARIABLES"]][[params$variable]][["daily"]]) {", hour, sun's elevation & azimuth"}` and the daily daylight amount in seconds as a predictors too.

```{r metrics_paired}
models <- res |> select(-c("time", "reanalysis")) |> colnames()

if(conf[["VARIABLES"]][[params$variable]][["daily"]]){
  if(params$variable == "pr"){
    r <- lapply(models, function(x) {
      metrics_paired_hourly_rain(time = res$time, truth = res$reanalysis, estimate = res[[x]], model = x)
    })    
  } else {
    r <- lapply(models, function(x) {
      metrics_paired_hourly(time = res$time, truth = res$reanalysis, estimate = res[[x]], model = x)
    })    
  }
} else {
  r <- lapply(models, function(x) {
    metrics_paired_daily(time = res$time, truth = res$reanalysis, estimate = res[[x]], model = x)
  })  
}

results <- do.call(rbind, r)

results <- results |>
  mutate(across(where(is.numeric), \(x) round(x, digits = 3) ) )

tabla <- results
kable(tabla)
```

```{asis, echo=conf[["VARIABLES"]][[params$variable]][["daily"]]}

### Amplitude MAE 

$$
 \frac{\sum_{d=1}^D |A_d - \hat{A}_d|}{D}
$$

**Where**

  * $D$ Number of days.
  * $A_d$: is the amplitude of day d, defined as the difference between the highest and lowest temperatures of that day.
  * $\hat{A}_d$: Estimated amplitude of day d.
  
### Maximum error

$$
\frac{\sum_{d=1}^D |{mh}_d - \hat{mh}_d|}{D}
$$

**Where**

  * $D$: Number of days.
  * $mh_d$: is the actual hour of the day when the peak occurred on day $d$.
  * $\hat{mh}_d$: is the estimated hour of the day when the peak occurred on day $d$.

Lower values are better.

### Sign correlation

$$
\frac{\sum^{N}_{n=1}1_{sg(X_{n+1} - X_{n}) = sg(\hat{X}_{n+1} - \hat{X}_{n}))}}{N-1}
$$

**Where**

  * $N$: number of observations
  * $sg$: is the sign function
  * $X_n,X_n+1$: are the actual values of observation $n$ and $n+1$.
  * $\hat{X}_n, \hat{X}_{n+1}$: are the estimated values for observation $n$ and $n+1$.
  
The function $\mathbb{1}{sg(X{n+1} - X_{n}) = sg(\hat{X}{n+1} - \hat{X}{n})}$ is an indicator function that equals 1 when the direction of change in the actual series matches the direction of change in the estimated series (i.e., if the actual series increases, the estimated series also increases, or if the actual series decreases, the estimated series also decreases), and equals 0 otherwise.

The possible values of this indicator range between 0 (meaning that whenever the actual series increases, the estimated series decreases, or vice versa) and 1 (meaning that the estimated series always follows the same direction as the actual series). Higher values are preferable.

### Extreme correlation

$$
\sum_{d | d \in D*} \frac{\mathbb{1}_{E_d=\hat{E}_d}}{|D*|}
$$

**Where**

  * $D*$: Days that have an extreme value.
  * $E_d$: A binary indicator for whether day d has an extreme value (1 if it does, 0 otherwise) in the observed data.
  * $\hat{E}_d$: A binary indicator for whether day d is predicted to have an extreme value (1 if it does, 0 otherwise) based on the model.

The function $\mathbb{1}_{E_d=\hat{E}_d}}$ is an indicator function that equals 1 when both of the days have and extreme value and 0 when one has an extreme value but the other does not.

The possible values of this indicator range between 0 (the days with extremes in the actual serie and the estimated serie never match) and 1 (the days with extremes always match). Higher values are preferable.
```

## Rotated QQ Plot

```{r qqplot, fig.height=8, fig.width=6}
pps <- (0:99+.5)/100
res |> 
  pivot_longer(cols = -c(1:2), values_to = 'value', 
               names_to = 'model') |> 
  group_by(model) |> 
  reframe(qq.obs  = quantile(reanalysis, probs = pps),
          qq.pred = quantile(value, probs = pps, na.rm = TRUE),
          per = pps) |> 
  ggplot() + 
  geom_line(aes( y=qq.pred-qq.obs, x=per, color=model)) + 
  geom_hline(yintercept = 0, linetype='dashed') + 
  scale_color_brewer(palette = 'Dark2') + 
  theme_bw()
```

## Autocorrelogram

```{r acf}
models <- res |> select(-c("time")) |> colnames()

r <- lapply(models, function(x) {
  acf(res[[x]], lag.max = 47, plot = F)$acf
}) |> set_names(nm = models) |> 
  bind_rows( .id='models')
2

results <- as_tibble(results)

results <- results |> 
  pivot_longer(cols = everything(), names_to = "model", values_to = "acf")

results$lag <- sort(rep(1:48, length(models)))

results <- results |> filter(lag > 1) #I don't want to plot the first lag

results |> 
  ggplot() +
    geom_line( aes(lag, acf, color=model) )



```

## Extremogram

*Important:* Right now we are only estimating the upper tail extremogram. Currently we didn't find a way to estimate the two tales at the same time. We are using `quant = .97`

```{r extremogram}
models <- res |> select(-c("time")) |> colnames()

r <- lapply(models, function(x) {
  extremogram1(res[[x]], 
               quant = .97, maxlag = 48, type = 1, ploting = 0)
})

results <- do.call(cbind, r)

colnames(results) <- models

results <- as_data_frame(results)

results <- results |> pivot_longer(cols = everything(), names_to = "model", values_to = "extremogram")
results$lag <- sort(rep(1:48, length(models)))

results <- results |> filter(lag > 1) #I don't want to plot the first lag

ggplot(results, mapping = aes(x = lag, y = extremogram)) +
    geom_segment(mapping = aes(xend = lag, yend = 0)) +
    facet_wrap(~ model, nrow = 2)
```

## Model Explanation

### XGBoost

```{r xgboost_load_model}
# Use reticulate to import Python modules
pickle <- import("pickle")
builtins <- import_builtins()  # This imports Python's built-in functions, including 'open'

x <- paste0('models/', params$variable, "/xgboost.pkl")

# Load the model from the pickle file
with(builtins$open(x, "rb") %as% f, {
  xgboost <- pickle$load(f)
})
```

```{r xgboost_explanation}
importance <- data.frame(features = unlist(xgboost$feature_names_in_), importance = unlist(xgboost$feature_importances_)) |>
                arrange(desc(importance)) |> head(10)
# Create a ggplot2-based variable importance plot
ggplot(importance, aes(x = importance, y = reorder(features, importance))) +
  geom_bar(stat = "identity", fill = "dodgerblue") +
  labs(
    title = "Variable Importance",
    x = "Importance",
    y = "Feature"
  ) +
  theme_minimal()
```