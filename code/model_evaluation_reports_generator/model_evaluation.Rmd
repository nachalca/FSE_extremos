---
title: "`r paste0('Model evaluation for ', params$variable)`"
params:
  variable: "sfcWind" #Use pr as default
output: html_document
---

```{r setup, include=FALSE}
library(here)
knitr::opts_knit$set(root.dir = here())
knitr::opts_chunk$set(echo = F, warning = F)
```

```{css}
/* Define a margin before h2 element */
h2,h3  {
  margin-top: 3em;
}
```

```{r imports, results=F}
library(ggplot2)
library(tidyverse)
library(knitr)
library(gridExtra)
Sys.setenv(RETICULATE_PYTHON = "/home/tancre/bin/miniconda3/bin/python")
library(reticulate)
library(yaml)
library("extremogram")
source('code/metrics.R')
source('code/utils.R')
```

```{r load_test_data}
x <- paste0('data/testing/', params$variable, ".csv")
variable <- read.csv(x)

res <- data.frame(time = variable$time, reanalysis = variable$target)

#Load configuration
conf <- yaml.load_file("code/conf.yml")
```

The observations for the validation were taken from `r min(res$time)` to `r max(res$time)`.

```{r predictions}
# Use reticulate to import Python modules
xgb <- import_from_path("XgboostDownscaler", path = paste0(here(), "/code"))
xgboost_downscaler <- xgb$XgboostDownscaler()

xgboost_predictions <- xgboost_downscaler$predict(model = paste0(here(), "/models/", params$variable, "/xgboost.pkl"), 
                           data = paste0(here(), "/data/testing/", params$variable, ".csv"))

```

```{r cnn_predictions}
# Use reticulate to import Python modules
cnn <- import_from_path("CNNDownscaler", path = paste0(here(), "/code"))
cnn_downscaler <- cnn$CNNDownscaler()

cnn_predictions <- cnn_downscaler$predict(model = paste0(here(), "/models/", params$variable, "/cnn.pkl"), 
                           data = paste0(here(), "/data/testing/", params$variable, ".csv"))
```



```{r res_dataframe, results=F}
res <- res |> 
  inner_join(xgboost_predictions, by = join_by(time)) |>
  inner_join(cnn_predictions, by = join_by(time))
```

```{r metrics_2}
models <- res |> select(-c("time", "reanalysis")) |> colnames()

r <- lapply(models, function(x) {
    metrics_2(time = res$time, truth = res$reanalysis, estimate = res[[x]], model = x)
})

results <- do.call(rbind, r)

results <- results |>
  mutate(across(where(is.numeric), round, digits = 3)) 

kable(results)
```

### Time series of the first days

```{r show_plot, echo=FALSE}
res_to_plot <- res[0:72,] 

series_plot <- function(data, col) {
  time  <- data$time
  reanalysis <- data$reanalysis
  column <- data[[col]]
  
  p <- data.frame(time =  as.POSIXct(time), #To plot the time as the x-axis 
                  reanalysis = reanalysis, 
                  column = column)

  ggplot(p, aes(x=time)) +
    geom_line(aes(y=reanalysis)) +
    geom_line(aes(y=column), color = "red") + 
    labs(y = params$variable, x = "", title = col)
}

# Serie to compare to reanalysis
models <- res |> select(-c("time", "reanalysis")) |> colnames()

# Generate Q-Q plots
plots <- lapply(models, function(col) series_plot(res_to_plot, col))

# Arrange the plots using gridExtra
do.call(grid.arrange, c(plots, ncol = 1))
```

`r  if (conf[["VARIABLES"]][[params$variable]][["daily"]]) {"### How Often Peaks Hit Hourly\n"} else {"### Distribution of daily values by month\n"}`

```{r maximum, fig.height=9}
if (conf[["VARIABLES"]][[params$variable]][["daily"]]) {
  models <- res |> select(-c("time", "reanalysis")) |> colnames()
  
  plots <- lapply(models, function(col) {
    maximum_histograms(res$time, res$reanalysis, res[[col]]) + scale_fill_discrete(labels = c(col, "reanalysis"))
  })
  
  do.call(grid.arrange, c(plots, ncol = 1))
} else {
  models <- res |> select(-c("time", "reanalysis")) |> colnames()
  
  plots <- lapply(models, function(col) {
    monthly_boxplot(res$time, res$reanalysis, res[[col]]) + scale_fill_discrete(labels = c(col, "reanalysis"))
  })
  
  do.call(grid.arrange, c(plots, ncol = 1))
}
```

`r  if (conf[["VARIABLES"]][[params$variable]][["daily"]]) {"### New plot\n"}`

```{r, fig.height=9, fig.width=6}
if (conf[["VARIABLES"]][[params$variable]][["daily"]]){
  res_to_plot <- res |> 
      mutate(date = getDate(time)) |> 
      group_by(date) |>
      mutate(daily_avg = mean(reanalysis)) |>
      ungroup() |>
      mutate(hour = getHour(time))

  p1 <- ggplot(res_to_plot, aes(x=daily_avg, y=reanalysis)) +
    geom_line() +
    labs(title = "Reanalysis") +
    facet_wrap(~hour)
  
  p2 <- ggplot(res_to_plot, aes(x=daily_avg, y=xgboost)) +
    geom_line() +
    labs(title = "Xgboost") +
    facet_wrap(~hour)
  grid.arrange(p1, p2, newpage = T)
}
```

### QQ Plot

```{r qqplot, fig.height=8, fig.width=6}
# Function to create a Q-Q plot comparing quantiles of a sample column against a reference column
qq_plot_against <- function(data, sample_col) {
  ref_col <- "reanalysis"
  sample_data <- data[[sample_col]]
  ref_data <- data[[ref_col]]
  
  # Sort the data
  sample_data_sorted <- sort(sample_data)
  ref_data_sorted <- sort(ref_data)
  
  # Calculate quantiles
  n <- min(length(sample_data_sorted), length(ref_data_sorted))
  quantiles_sample <- sample_data_sorted[seq(1, length(sample_data_sorted), length.out = n)]
  quantiles_ref <- ref_data_sorted[seq(1, length(ref_data_sorted), length.out = n)]
  
  # Create a data frame for plotting
  quantile_df <- data.frame(Quantiles_Ref = quantiles_ref, Quantiles_Sample = quantiles_sample)
  
  # Generate the Q-Q plot
  ggplot(quantile_df, aes(x = Quantiles_Ref, y = Quantiles_Sample)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
    ggtitle(paste(sample_col)) +
    labs(x = NULL, y = NULL) +
    theme_minimal()
}

# Columns to compare against the reference column
models <- res |> select(-c("time", "reanalysis")) |> colnames()
# Generate Q-Q plots
plots <- lapply(models, function(col) qq_plot_against(res, col))

# Arrange the plots using gridExtra
do.call(grid.arrange, c(plots, ncol = 1))  # Arrange in a grid
```

### Autocorrelogram

```{r acf}
models <- res |> select(-c("time")) |> colnames()
r <- lapply(models, function(x) {
  acf(res[[x]], lag.max = 47, plot = F)$acf
})

results <- do.call(cbind, r)

colnames(results) <- models

results <- as_data_frame(results)

results <- results |> pivot_longer(cols = everything(), names_to = "model", values_to = "acf")
results$lag <- sort(rep(1:48, length(models)))

results <- results |> filter(lag > 1) #I don't want to plot the first lag

ggplot(results, mapping = aes(x = lag, y = acf)) +
    geom_segment(mapping = aes(xend = lag, yend = 0)) +
    facet_wrap(~ model, nrow = 2) 
```

### Extremogram

```{r extremogram}
models <- res |> select(-c("time")) |> colnames()

r <- lapply(models, function(x) {
  extremogram1(res[[x]], quant = .97, maxlag = 48, type = 1, ploting = 0)
})

results <- do.call(cbind, r)

colnames(results) <- models

results <- as_data_frame(results)

results <- results |> pivot_longer(cols = everything(), names_to = "model", values_to = "extremogram")
results$lag <- sort(rep(1:48, length(models)))

results <- results |> filter(lag > 1) #I don't want to plot the first lag

ggplot(results, mapping = aes(x = lag, y = extremogram)) +
    geom_segment(mapping = aes(xend = lag, yend = 0)) +
    facet_wrap(~ model, nrow = 2)
```

## Model Explanation

### XGBoost

```{r xgboost_load_model}
# Use reticulate to import Python modules
pickle <- import("pickle")
builtins <- import_builtins()  # This imports Python's built-in functions, including 'open'

x <- paste0('models/', params$variable, "/xgboost.pkl")

# Load the model from the pickle file
with(builtins$open(x, "rb") %as% f, {
  xgboost <- pickle$load(f)
})
```

```{r xgboost_explanation}
importance <- data.frame(features = unlist(xgboost$feature_names_in_), importance = unlist(xgboost$feature_importances_)) |>
                arrange(desc(importance)) |> head(10)
# Create a ggplot2-based variable importance plot
ggplot(importance, aes(x = importance, y = reorder(features, importance))) +
  geom_bar(stat = "identity", fill = "dodgerblue") +
  labs(
    title = "Variable Importance",
    x = "Importance",
    y = "Feature"
  ) +
  theme_minimal()
```